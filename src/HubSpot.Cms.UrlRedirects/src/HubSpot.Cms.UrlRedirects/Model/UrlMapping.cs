/*
 * URL redirects
 *
 * URL redirect operations
 *
 * The version of the OpenAPI document: v3
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = HubSpot.Cms.UrlRedirects.Client.OpenAPIDateConverter;

namespace HubSpot.Cms.UrlRedirects.Model
{
    /// <summary>
    /// UrlMapping
    /// </summary>
    [DataContract(Name = "UrlMapping")]
    public partial class UrlMapping : IEquatable<UrlMapping>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="UrlMapping" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected UrlMapping() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="UrlMapping" /> class.
        /// </summary>
        /// <param name="id">The unique ID of this URL redirect. (required).</param>
        /// <param name="routePrefix">The target incoming URL, path, or pattern to match for redirection. (required).</param>
        /// <param name="destination">The destination URL, where the target URL should be redirected if it matches the &#x60;routePrefix&#x60;. (required).</param>
        /// <param name="redirectStyle">The type of redirect to create. Options include: 301 (permanent), 302 (temporary), or 305 (proxy). Find more details [here](https://knowledge.hubspot.com/cos-general/how-to-redirect-a-hubspot-page). (required).</param>
        /// <param name="isOnlyAfterNotFound">Whether the URL redirect mapping should apply only if a live page on the URL isn&#39;t found. If False, the URL redirect mapping will take precedence over any existing page. (required).</param>
        /// <param name="isMatchFullUrl">Whether the &#x60;routePrefix&#x60; should match on the entire URL, including the domain. (required).</param>
        /// <param name="isMatchQueryString">Whether the &#x60;routePrefix&#x60; should match on the entire URL path, including the query string. (required).</param>
        /// <param name="isPattern">Whether the &#x60;routePrefix&#x60; should match based on pattern. (required).</param>
        /// <param name="isTrailingSlashOptional">Whether a trailing slash will be ignored. (required).</param>
        /// <param name="isProtocolAgnostic">Whether the &#x60;routePrefix&#x60; should match both HTTP and HTTPS protocols. (required).</param>
        /// <param name="precedence">Used to prioritize URL redirection. If a given URL matches more than one redirect, the one with the **lower** precedence will be used. (required).</param>
        /// <param name="created">created.</param>
        /// <param name="updated">updated.</param>
        public UrlMapping(string id = default(string), string routePrefix = default(string), string destination = default(string), int redirectStyle = default(int), bool isOnlyAfterNotFound = default(bool), bool isMatchFullUrl = default(bool), bool isMatchQueryString = default(bool), bool isPattern = default(bool), bool isTrailingSlashOptional = default(bool), bool isProtocolAgnostic = default(bool), int precedence = default(int), DateTime created = default(DateTime), DateTime updated = default(DateTime))
        {
            // to ensure "id" is required (not null)
            if (id == null)
            {
                throw new ArgumentNullException("id is a required property for UrlMapping and cannot be null");
            }
            this.Id = id;
            // to ensure "routePrefix" is required (not null)
            if (routePrefix == null)
            {
                throw new ArgumentNullException("routePrefix is a required property for UrlMapping and cannot be null");
            }
            this.RoutePrefix = routePrefix;
            // to ensure "destination" is required (not null)
            if (destination == null)
            {
                throw new ArgumentNullException("destination is a required property for UrlMapping and cannot be null");
            }
            this.Destination = destination;
            this.RedirectStyle = redirectStyle;
            this.IsOnlyAfterNotFound = isOnlyAfterNotFound;
            this.IsMatchFullUrl = isMatchFullUrl;
            this.IsMatchQueryString = isMatchQueryString;
            this.IsPattern = isPattern;
            this.IsTrailingSlashOptional = isTrailingSlashOptional;
            this.IsProtocolAgnostic = isProtocolAgnostic;
            this.Precedence = precedence;
            this.Created = created;
            this.Updated = updated;
        }

        /// <summary>
        /// The unique ID of this URL redirect.
        /// </summary>
        /// <value>The unique ID of this URL redirect.</value>
        [DataMember(Name = "id", IsRequired = true, EmitDefaultValue = true)]
        public string Id { get; set; }

        /// <summary>
        /// The target incoming URL, path, or pattern to match for redirection.
        /// </summary>
        /// <value>The target incoming URL, path, or pattern to match for redirection.</value>
        [DataMember(Name = "routePrefix", IsRequired = true, EmitDefaultValue = true)]
        public string RoutePrefix { get; set; }

        /// <summary>
        /// The destination URL, where the target URL should be redirected if it matches the &#x60;routePrefix&#x60;.
        /// </summary>
        /// <value>The destination URL, where the target URL should be redirected if it matches the &#x60;routePrefix&#x60;.</value>
        [DataMember(Name = "destination", IsRequired = true, EmitDefaultValue = true)]
        public string Destination { get; set; }

        /// <summary>
        /// The type of redirect to create. Options include: 301 (permanent), 302 (temporary), or 305 (proxy). Find more details [here](https://knowledge.hubspot.com/cos-general/how-to-redirect-a-hubspot-page).
        /// </summary>
        /// <value>The type of redirect to create. Options include: 301 (permanent), 302 (temporary), or 305 (proxy). Find more details [here](https://knowledge.hubspot.com/cos-general/how-to-redirect-a-hubspot-page).</value>
        [DataMember(Name = "redirectStyle", IsRequired = true, EmitDefaultValue = true)]
        public int RedirectStyle { get; set; }

        /// <summary>
        /// Whether the URL redirect mapping should apply only if a live page on the URL isn&#39;t found. If False, the URL redirect mapping will take precedence over any existing page.
        /// </summary>
        /// <value>Whether the URL redirect mapping should apply only if a live page on the URL isn&#39;t found. If False, the URL redirect mapping will take precedence over any existing page.</value>
        [DataMember(Name = "isOnlyAfterNotFound", IsRequired = true, EmitDefaultValue = true)]
        public bool IsOnlyAfterNotFound { get; set; }

        /// <summary>
        /// Whether the &#x60;routePrefix&#x60; should match on the entire URL, including the domain.
        /// </summary>
        /// <value>Whether the &#x60;routePrefix&#x60; should match on the entire URL, including the domain.</value>
        [DataMember(Name = "isMatchFullUrl", IsRequired = true, EmitDefaultValue = true)]
        public bool IsMatchFullUrl { get; set; }

        /// <summary>
        /// Whether the &#x60;routePrefix&#x60; should match on the entire URL path, including the query string.
        /// </summary>
        /// <value>Whether the &#x60;routePrefix&#x60; should match on the entire URL path, including the query string.</value>
        [DataMember(Name = "isMatchQueryString", IsRequired = true, EmitDefaultValue = true)]
        public bool IsMatchQueryString { get; set; }

        /// <summary>
        /// Whether the &#x60;routePrefix&#x60; should match based on pattern.
        /// </summary>
        /// <value>Whether the &#x60;routePrefix&#x60; should match based on pattern.</value>
        [DataMember(Name = "isPattern", IsRequired = true, EmitDefaultValue = true)]
        public bool IsPattern { get; set; }

        /// <summary>
        /// Whether a trailing slash will be ignored.
        /// </summary>
        /// <value>Whether a trailing slash will be ignored.</value>
        [DataMember(Name = "isTrailingSlashOptional", IsRequired = true, EmitDefaultValue = true)]
        public bool IsTrailingSlashOptional { get; set; }

        /// <summary>
        /// Whether the &#x60;routePrefix&#x60; should match both HTTP and HTTPS protocols.
        /// </summary>
        /// <value>Whether the &#x60;routePrefix&#x60; should match both HTTP and HTTPS protocols.</value>
        [DataMember(Name = "isProtocolAgnostic", IsRequired = true, EmitDefaultValue = true)]
        public bool IsProtocolAgnostic { get; set; }

        /// <summary>
        /// Used to prioritize URL redirection. If a given URL matches more than one redirect, the one with the **lower** precedence will be used.
        /// </summary>
        /// <value>Used to prioritize URL redirection. If a given URL matches more than one redirect, the one with the **lower** precedence will be used.</value>
        [DataMember(Name = "precedence", IsRequired = true, EmitDefaultValue = true)]
        public int Precedence { get; set; }

        /// <summary>
        /// Gets or Sets Created
        /// </summary>
        [DataMember(Name = "created", EmitDefaultValue = false)]
        public DateTime Created { get; set; }

        /// <summary>
        /// Gets or Sets Updated
        /// </summary>
        [DataMember(Name = "updated", EmitDefaultValue = false)]
        public DateTime Updated { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class UrlMapping {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  RoutePrefix: ").Append(RoutePrefix).Append("\n");
            sb.Append("  Destination: ").Append(Destination).Append("\n");
            sb.Append("  RedirectStyle: ").Append(RedirectStyle).Append("\n");
            sb.Append("  IsOnlyAfterNotFound: ").Append(IsOnlyAfterNotFound).Append("\n");
            sb.Append("  IsMatchFullUrl: ").Append(IsMatchFullUrl).Append("\n");
            sb.Append("  IsMatchQueryString: ").Append(IsMatchQueryString).Append("\n");
            sb.Append("  IsPattern: ").Append(IsPattern).Append("\n");
            sb.Append("  IsTrailingSlashOptional: ").Append(IsTrailingSlashOptional).Append("\n");
            sb.Append("  IsProtocolAgnostic: ").Append(IsProtocolAgnostic).Append("\n");
            sb.Append("  Precedence: ").Append(Precedence).Append("\n");
            sb.Append("  Created: ").Append(Created).Append("\n");
            sb.Append("  Updated: ").Append(Updated).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as UrlMapping);
        }

        /// <summary>
        /// Returns true if UrlMapping instances are equal
        /// </summary>
        /// <param name="input">Instance of UrlMapping to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(UrlMapping input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Id == input.Id ||
                    (this.Id != null &&
                    this.Id.Equals(input.Id))
                ) && 
                (
                    this.RoutePrefix == input.RoutePrefix ||
                    (this.RoutePrefix != null &&
                    this.RoutePrefix.Equals(input.RoutePrefix))
                ) && 
                (
                    this.Destination == input.Destination ||
                    (this.Destination != null &&
                    this.Destination.Equals(input.Destination))
                ) && 
                (
                    this.RedirectStyle == input.RedirectStyle ||
                    this.RedirectStyle.Equals(input.RedirectStyle)
                ) && 
                (
                    this.IsOnlyAfterNotFound == input.IsOnlyAfterNotFound ||
                    this.IsOnlyAfterNotFound.Equals(input.IsOnlyAfterNotFound)
                ) && 
                (
                    this.IsMatchFullUrl == input.IsMatchFullUrl ||
                    this.IsMatchFullUrl.Equals(input.IsMatchFullUrl)
                ) && 
                (
                    this.IsMatchQueryString == input.IsMatchQueryString ||
                    this.IsMatchQueryString.Equals(input.IsMatchQueryString)
                ) && 
                (
                    this.IsPattern == input.IsPattern ||
                    this.IsPattern.Equals(input.IsPattern)
                ) && 
                (
                    this.IsTrailingSlashOptional == input.IsTrailingSlashOptional ||
                    this.IsTrailingSlashOptional.Equals(input.IsTrailingSlashOptional)
                ) && 
                (
                    this.IsProtocolAgnostic == input.IsProtocolAgnostic ||
                    this.IsProtocolAgnostic.Equals(input.IsProtocolAgnostic)
                ) && 
                (
                    this.Precedence == input.Precedence ||
                    this.Precedence.Equals(input.Precedence)
                ) && 
                (
                    this.Created == input.Created ||
                    (this.Created != null &&
                    this.Created.Equals(input.Created))
                ) && 
                (
                    this.Updated == input.Updated ||
                    (this.Updated != null &&
                    this.Updated.Equals(input.Updated))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Id != null)
                {
                    hashCode = (hashCode * 59) + this.Id.GetHashCode();
                }
                if (this.RoutePrefix != null)
                {
                    hashCode = (hashCode * 59) + this.RoutePrefix.GetHashCode();
                }
                if (this.Destination != null)
                {
                    hashCode = (hashCode * 59) + this.Destination.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.RedirectStyle.GetHashCode();
                hashCode = (hashCode * 59) + this.IsOnlyAfterNotFound.GetHashCode();
                hashCode = (hashCode * 59) + this.IsMatchFullUrl.GetHashCode();
                hashCode = (hashCode * 59) + this.IsMatchQueryString.GetHashCode();
                hashCode = (hashCode * 59) + this.IsPattern.GetHashCode();
                hashCode = (hashCode * 59) + this.IsTrailingSlashOptional.GetHashCode();
                hashCode = (hashCode * 59) + this.IsProtocolAgnostic.GetHashCode();
                hashCode = (hashCode * 59) + this.Precedence.GetHashCode();
                if (this.Created != null)
                {
                    hashCode = (hashCode * 59) + this.Created.GetHashCode();
                }
                if (this.Updated != null)
                {
                    hashCode = (hashCode * 59) + this.Updated.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
